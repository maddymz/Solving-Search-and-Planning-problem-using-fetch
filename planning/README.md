Carry out the following steps to set up the environment for this assignment.
<ol>
	<li>Clone this repository to your catkin_ws/src.</li>
	<li>Copy all the folders from Models/ and paste it to your ~/.gazebo/Models </li>
	<li>Copy _4__5.jpg and basket.dae from turtle_basket folder to your catkin_ws/src/turtlebot3/turtlbot3_description/meshes/basket. You will need to create the "basket" folder.</li>
	<li> Copy turtlebot3_waffle.urdf.xacro to your catkin_ws/src/turtlebot3/turtlbot3_description/urdf/ </li>
	<li> You will need to use "waffle" model for this assignment.</li>
	<li>Run catkin_make from your catkin_ws. </li>
	<li>Run source devel/setup.bash from your catkin_ws</li>
	<li>In catkin_ws/src/Planning/scirpts/server.py change root_path to your catkin_ws/src/Planning. Please use absolute path.</li>
</ol>
<br>
<br>
To start the execution, you will first need to run <b>"server.py"</b>. This will generate a random environment which can be run in Gazebo using launch file <b>"maze.launch"</b>. This will also generate partial PDDL problem file with objects and initial state. You can specify the number of subjects using the  argument "-sub". To enable the turtlebot3 to move, you will need to run move_tbot3.py 
<br>
<ul>
<li>To run server file, execute <b>rosrun planning server.py</b>
	<li>To launch maze in gazebo, execute <b>roslaunch planning maze.launch</b></li>
	<li>To run move_tbot3.py, execute <b>rosrun planning move_tbot3.py</b></li>
</ul>

Your PDDL file should contain the following actions.
<ol>
<li>Pick: This action picks the book from floor and puts it in the basket on the Turtlebot3. To execute this action, you can use the service "execute_pick_action" which is available in PlanningAPI provided to you. It returns 1 if it is successfully executed, -1 otherwise.</li>
<li> Place: This actions places the book in the bin from the basket on the Turtlebot3. To execute this actions, you can use the service "execute_place_action" which is available in PlanningAPI provided to you. It returns 1 if it is successfully executed, -1 otherwise.</li>
<li>Move: This action is used to change the location of the Turtlebot3. You will need to write downward refinement code for this action to convert single "Move" action to sequence of low-level actions ("MoveF","MoveB","TurnCW","TurnCCW"). Once you obtain sequcece of low-level actions, you can use the service "execute_move_action", which is available in PlanningAPI provided to you,  with list of these action to execute actions. To obtain the exact location of books and bins, use the object_dict provided by the server. You can access each book and bin from some defined locations. These locations can be found in object_dict as "load_loc".
</li>
</ol>
<br>
Apart from above mentioned services, PlanningAPI contains all the services required by your previous search algorithms.
<br>
You should use the following predicates to define the PDDL domain. You can use any other predicates for other relations.
<ul>    
	<li> (Book_At book_name book_location) - To specify location of book </li>
    <li> (Bin_At bin_name bin_location) - To specify location of bin </li>
    <li> (Robot_At robot_name robot_location) - To specify location of robot </li>
    <li> (Bin_Size bin_name size ) - To specify size of bin </li>
    <li> (Book_Size book_name size) - To specify size of book </li>
    <li> (Book_Subject book_name subject) - To specify subject of the book </li>
    <li> (Bin_Subject bin_name subject) - To specfiy subject of the bin </li>
    <li> (Empty_Basket robot) - To specify that robot's basket is empty </li>
</ul>
<br>
To get the goal location to find downward refinement of the move action, use the object_dict.json generated by the server in the project root path. This contains all the details of the books and bins such as name, subject, size, initial location and location from where you can access the object.
<br><br>
While executing the actions, downward refined move actions takes time to execute, so you will need to wait until the execution is done. The execution code publishes "Idle" when it is ready to except new action. So your code should subscribe to topic "/status" and wait for "Idle" to send next action after you run the first action (To execute first action you do need to wait as initailly it is idle).
